<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>基本类型和引用类型的值-变量、作用域和内存问题-JavaScript高级程序设计</title>
</head>
<body>
基本类型值是简单的数据段。
引用类型值是保存在内存中的对象。
在javascript中，操作对象时，实际上操作的是对象的引用，而不是保存在内存中的实际的对象。为此，引用类型的值是按引用访问的。
基本类型值复制：
<script type="text/javascript">
	var num1 = 22;
	var num2 = num1;
	num1 = 80;
	console.log(num1 + "\n" + num2);
	console.log("----------");
</script>
引用类型值复制：
<script type="text/javascript">
	var obj1 = new Object();
	obj1.name = "Wang";
	var obj2 = obj1;
	console.log(obj2.name);
	obj2.name = "Feng";
	console.log(obj2.name);
	console.log(obj1.name);
	console.log("----------");
</script>

<hr>
4.1.3 传递参数
在ECMAScript中，所有参数都是按值传递的。
<script type="text/javascript">
	function setName (obj) {
		obj.name = "Li Qingting";
		obj = new Object();
		obj.name = "Feng Lin";
	}
	function setName2 (obj) {
		obj = new Object();
		obj.name = "Li Qingting";
		obj.name = "Feng Lin";
	}
	var person = new Object();
	var person2 = new Object();
	setName(person);
	console.log(person.name);
	setName2(person2);
	console.log(person2.name);
	console.log("----------");
</script>

<hr>
4.1.4 检测类型
typeof 操作符，检测基本数据类型；
instanceof 操作符，检测引用数据类型。

所有引用类型的值都是Object的实例，因此，在检测一个引用类型的值和Object构造函数时，返回的值始终是true。
如果使用instanceof操纵符检测基本类型值，返回的始终是false。

<script type="text/javascript">
	var s = "abcdefg",
		n = 88,
		b = true,
		ary = ['1', '2', '3'];
		obj = {name: 'A U', age: 2};
	var fun = function () {
		return "我是一个引用类型值"
	}
	console.log(typeof s);
	console.log(typeof n);
	console.log(typeof b);
	console.log(typeof ary);
	console.log(typeof obj);
	console.log(typeof fun);
	console.log(ary instanceof Array);
	console.log(fun instanceof Object);
	console.log(obj instanceof Object);
	console.log(fun instanceof Function);
	console.log(obj instanceof Function);
</script>

</body>
</html>