<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>23.2 应用缓存 - 离线应用与客户端存储</title>
</head>

<body>
    23.2 应用缓存
-------------------------------------
    HTML5的应用缓存（application cache），简称appcache。是专门为开发离线Web应用而设计的。
    Appcache就是从浏览器的缓存中分出来的一块缓存区。要想在这个缓存中保存数据，可以使用一个描述文件（manifest file），列出要下载或缓存的资源。
    下面是一个简单的描述文件示例：
    ------------------
    CACHE MANIFEST
    #Comment

    file.js
    file.css
    ------------------
    在最简单的情况下，描述文件中列出的都是需要下载的资源，以备离线时使用。

    要将描述文件与页面关联起来，可以在 html 标签中的manifest属性中指定这个文件的路径。例如：
    <!--
        <html manifest="/offline.manifest"></html>
    -->
    以上代码告诉页面，/offline.manifest中包含着描述文件。这个文件的MIME类型必须是text/cache-manifest。
    ------------------
    * 描述文件的扩展名以前推荐用manifest，但现在推荐的是appcache。



    虽然应用缓存的意图是确保离线时资源可用，但也有相应的JavaScript APP 让你知道它都在做什么。
    这个APP的核心是applicationCache对象，这个对象有一个status属性，属性的值是常量，表示应用缓存的如下当前状态：
    -----------------------------------------------------------
    · 0：无缓存，即每月与页面相关的应用缓存。
    · 1：闲置，即应用缓存未得到更新。
    · 2：检查中，即正在下载描述文件并检查更新。
    · 3：下载中，即应用缓存正在下载描述文件中指定的资源。
    · 4：更新完成，即应用缓存已经更新了资源，并且所有资源都已下载完毕，可以通过swapCache()来使用了。
    · 5：废弃，即应用缓存的描述文件已经不存在了，因此页面无法再访问应用缓存。

    应用缓存还有很多相关的事件，表示其状态的改变。以下是这些事件：
    · checking：在浏览器为应用缓存查找更新时触发。
    · error：在检查更新或下载资源期间发生错误时触发。
    · noupdate：在检查描述文件发现文件无变化时触发。
    · downloading：在开始下载应用缓存资源时触发。
    · progress：在文件下载应用缓存的过程中不断地触发。
    · updateready：在页面新的应用缓存下载完毕且可以通过swapCache()使用时触发。
    · cached：应用缓存完整可用时触发。
    -------------------------------------
    一般来讲，这些事件会随着页面加载按上述顺序依次触发。
    不过，通过调用update()方法也可以手工干预，让应用缓存为检查更新而触发上述事件。
    applicationCache.update()
    update()一经调用，应用缓存就会去检查描述文件是否更新（触发checking事件），然后就像页面刚刚加载一样，继续执行后续操作。
    如果触发了cached()事件，就说明应用缓存已经准备就绪，不会再发生其他操作了。
    如果触发了updateready事件，则说明新版本的应用缓存已经可用，而此时你需要调用swapCache()来启用新应用缓存。
    <script>
        applicationCache.addEventListener("updateready", function() {
            applicationCache.swapCache();
        });
    </script>

</body>

</html>